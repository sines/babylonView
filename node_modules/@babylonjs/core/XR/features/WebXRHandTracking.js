import { __assign, __extends } from "tslib";
import { WebXRAbstractFeature } from "./WebXRAbstractFeature";
import { WebXRFeatureName } from "../webXRFeaturesManager";
import { SphereBuilder } from "../../Meshes/Builders/sphereBuilder";
import { Quaternion } from "../../Maths/math.vector";
import { PhysicsImpostor } from "../../Physics/physicsImpostor";
import { WebXRFeaturesManager } from "../webXRFeaturesManager";
import { Observable } from "../../Misc/observable";
/**
 * Representing a single hand (with its corresponding native XRHand object)
 */
var WebXRHand = /** @class */ (function () {
    /**
     * Construct a new hand object
     * @param xrController the controller to which the hand correlates
     * @param trackedMeshes the meshes to be used to track the hand joints
     */
    function WebXRHand(
    /** the controller to which the hand correlates */
    xrController, 
    /** the meshes to be used to track the hand joints */
    trackedMeshes) {
        this.xrController = xrController;
        this.trackedMeshes = trackedMeshes;
        this.handPartsDefinition = this.generateHandPartsDefinition(xrController.inputSource.hand);
    }
    /**
     * Populate the HandPartsDefinition object.
     * This is called as a side effect since certain browsers don't have XRHand defined.
     */
    WebXRHand.prototype.generateHandPartsDefinition = function (hand) {
        var _a;
        return _a = {},
            _a["wrist" /* WRIST */] = [hand.WRIST],
            _a["thumb" /* THUMB */] = [hand.THUMB_METACARPAL, hand.THUMB_PHALANX_PROXIMAL, hand.THUMB_PHALANX_DISTAL, hand.THUMB_PHALANX_TIP],
            _a["index" /* INDEX */] = [hand.INDEX_METACARPAL, hand.INDEX_PHALANX_PROXIMAL, hand.INDEX_PHALANX_INTERMEDIATE, hand.INDEX_PHALANX_DISTAL, hand.INDEX_PHALANX_TIP],
            _a["middle" /* MIDDLE */] = [hand.MIDDLE_METACARPAL, hand.MIDDLE_PHALANX_PROXIMAL, hand.MIDDLE_PHALANX_INTERMEDIATE, hand.MIDDLE_PHALANX_DISTAL, hand.MIDDLE_PHALANX_TIP],
            _a["ring" /* RING */] = [hand.RING_METACARPAL, hand.RING_PHALANX_PROXIMAL, hand.RING_PHALANX_INTERMEDIATE, hand.RING_PHALANX_DISTAL, hand.RING_PHALANX_TIP],
            _a["little" /* LITTLE */] = [hand.LITTLE_METACARPAL, hand.LITTLE_PHALANX_PROXIMAL, hand.LITTLE_PHALANX_INTERMEDIATE, hand.LITTLE_PHALANX_DISTAL, hand.LITTLE_PHALANX_TIP],
            _a;
    };
    /**
     * Update this hand from the latest xr frame
     * @param xrFrame xrFrame to update from
     * @param referenceSpace The current viewer reference space
     * @param scaleFactor optional scale factor for the meshes
     */
    WebXRHand.prototype.updateFromXRFrame = function (xrFrame, referenceSpace, scaleFactor) {
        if (scaleFactor === void 0) { scaleFactor = 2; }
        var hand = this.xrController.inputSource.hand;
        if (!hand) {
            return;
        }
        this.trackedMeshes.forEach(function (mesh, idx) {
            var xrJoint = hand[idx];
            if (xrJoint) {
                var pose = xrFrame.getJointPose(xrJoint, referenceSpace);
                if (!pose || !pose.transform) {
                    return;
                }
                // get the transformation. can be done with matrix decomposition as well
                var pos = pose.transform.position;
                var orientation_1 = pose.transform.orientation;
                mesh.position.set(pos.x, pos.y, pos.z);
                mesh.rotationQuaternion.set(orientation_1.x, orientation_1.y, orientation_1.z, orientation_1.w);
                // left handed system conversion
                if (!mesh.getScene().useRightHandedSystem) {
                    mesh.position.z *= -1;
                    mesh.rotationQuaternion.z *= -1;
                    mesh.rotationQuaternion.w *= -1;
                }
                // get the radius of the joint. In general it is static, but just in case it does change we update it on each frame.
                var radius = (pose.radius || 0.008) * scaleFactor;
                mesh.scaling.set(radius, radius, radius);
            }
        });
    };
    /**
     * Get meshes of part of the hand
     * @param part the part of hand to get
     * @returns An array of meshes that correlate to the hand part requested
     */
    WebXRHand.prototype.getHandPartMeshes = function (part) {
        var _this = this;
        return this.handPartsDefinition[part].map(function (idx) { return _this.trackedMeshes[idx]; });
    };
    /**
     * Dispose this Hand object
     */
    WebXRHand.prototype.dispose = function () {
        this.trackedMeshes.forEach(function (mesh) { return mesh.dispose(); });
    };
    return WebXRHand;
}());
export { WebXRHand };
/**
 * WebXR Hand Joint tracking feature, available for selected browsers and devices
 */
var WebXRHandTracking = /** @class */ (function (_super) {
    __extends(WebXRHandTracking, _super);
    /**
     * Creates a new instance of the hit test feature
     * @param _xrSessionManager an instance of WebXRSessionManager
     * @param options options to use when constructing this feature
     */
    function WebXRHandTracking(_xrSessionManager, 
    /**
     * options to use when constructing this feature
     */
    options) {
        var _this = _super.call(this, _xrSessionManager) || this;
        _this.options = options;
        /**
         * This observable will notify registered observers when a new hand object was added and initialized
         */
        _this.onHandAddedObservable = new Observable();
        /**
         * This observable will notify its observers right before the hand object is disposed
         */
        _this.onHandRemovedObservable = new Observable();
        _this._hands = {};
        _this._attachHand = function (xrController) {
            var _a, _b, _c, _d;
            if (!xrController.inputSource.hand || _this._hands[xrController.uniqueId]) {
                // already attached
                return;
            }
            var hand = xrController.inputSource.hand;
            var trackedMeshes = [];
            var originalMesh = ((_a = _this.options.jointMeshes) === null || _a === void 0 ? void 0 : _a.sourceMesh) || SphereBuilder.CreateSphere("jointParent", { diameter: 1 });
            originalMesh.isVisible = !!((_b = _this.options.jointMeshes) === null || _b === void 0 ? void 0 : _b.keepOriginalVisible);
            for (var i = 0; i < hand.length; ++i) {
                var newInstance = originalMesh.createInstance(xrController.uniqueId + "-handJoint-" + i);
                if ((_c = _this.options.jointMeshes) === null || _c === void 0 ? void 0 : _c.onHandJointMeshGenerated) {
                    var returnedMesh = _this.options.jointMeshes.onHandJointMeshGenerated(newInstance, i, xrController.uniqueId);
                    if (returnedMesh) {
                        if (returnedMesh !== newInstance) {
                            newInstance.dispose();
                            newInstance = returnedMesh;
                        }
                    }
                }
                newInstance.isPickable = false;
                if ((_d = _this.options.jointMeshes) === null || _d === void 0 ? void 0 : _d.enablePhysics) {
                    var props = _this.options.jointMeshes.physicsProps || {};
                    var type = props.impostorType !== undefined ? props.impostorType : PhysicsImpostor.SphereImpostor;
                    newInstance.physicsImpostor = new PhysicsImpostor(newInstance, type, __assign({ mass: 0 }, props));
                }
                newInstance.rotationQuaternion = new Quaternion();
                trackedMeshes.push(newInstance);
            }
            var webxrHand = new WebXRHand(xrController, trackedMeshes);
            // get two new meshes
            _this._hands[xrController.uniqueId] = {
                handObject: webxrHand,
                id: WebXRHandTracking._idCounter++,
            };
            _this.onHandAddedObservable.notifyObservers(webxrHand);
        };
        _this.xrNativeFeatureName = "hand-tracking";
        return _this;
    }
    /**
     * Check if the needed objects are defined.
     * This does not mean that the feature is enabled, but that the objects needed are well defined.
     */
    WebXRHandTracking.prototype.isCompatible = function () {
        return typeof XRHand !== "undefined";
    };
    /**
     * attach this feature
     * Will usually be called by the features manager
     *
     * @returns true if successful.
     */
    WebXRHandTracking.prototype.attach = function () {
        var _this = this;
        if (!_super.prototype.attach.call(this)) {
            return false;
        }
        this.options.xrInput.controllers.forEach(this._attachHand);
        this._addNewAttachObserver(this.options.xrInput.onControllerAddedObservable, this._attachHand);
        this._addNewAttachObserver(this.options.xrInput.onControllerRemovedObservable, function (controller) {
            // REMOVE the controller
            _this._detachHand(controller.uniqueId);
        });
        return true;
    };
    /**
     * detach this feature.
     * Will usually be called by the features manager
     *
     * @returns true if successful.
     */
    WebXRHandTracking.prototype.detach = function () {
        var _this = this;
        if (!_super.prototype.detach.call(this)) {
            return false;
        }
        Object.keys(this._hands).forEach(function (controllerId) {
            _this._detachHand(controllerId);
        });
        return true;
    };
    /**
     * Dispose this feature and all of the resources attached
     */
    WebXRHandTracking.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.onHandAddedObservable.clear();
    };
    /**
     * Get the hand object according to the controller id
     * @param controllerId the controller id to which we want to get the hand
     * @returns null if not found or the WebXRHand object if found
     */
    WebXRHandTracking.prototype.getHandByControllerId = function (controllerId) {
        var _a;
        return ((_a = this._hands[controllerId]) === null || _a === void 0 ? void 0 : _a.handObject) || null;
    };
    /**
     * Get a hand object according to the requested handedness
     * @param handedness the handedness to request
     * @returns null if not found or the WebXRHand object if found
     */
    WebXRHandTracking.prototype.getHandByHandedness = function (handedness) {
        var _this = this;
        var handednesses = Object.keys(this._hands).map(function (key) { return _this._hands[key].handObject.xrController.inputSource.handedness; });
        var found = handednesses.indexOf(handedness);
        if (found !== -1) {
            return this._hands[found].handObject;
        }
        return null;
    };
    WebXRHandTracking.prototype._onXRFrame = function (_xrFrame) {
        var _this = this;
        // iterate over the hands object
        Object.keys(this._hands).forEach(function (id) {
            var _a;
            _this._hands[id].handObject.updateFromXRFrame(_xrFrame, _this._xrSessionManager.referenceSpace, (_a = _this.options.jointMeshes) === null || _a === void 0 ? void 0 : _a.scaleFactor);
        });
    };
    WebXRHandTracking.prototype._detachHand = function (controllerId) {
        if (this._hands[controllerId]) {
            this.onHandRemovedObservable.notifyObservers(this._hands[controllerId].handObject);
            this._hands[controllerId].handObject.dispose();
        }
    };
    WebXRHandTracking._idCounter = 0;
    /**
     * The module's name
     */
    WebXRHandTracking.Name = WebXRFeatureName.HAND_TRACKING;
    /**
     * The (Babylon) version of this module.
     * This is an integer representing the implementation version.
     * This number does not correspond to the WebXR specs version
     */
    WebXRHandTracking.Version = 1;
    return WebXRHandTracking;
}(WebXRAbstractFeature));
export { WebXRHandTracking };
//register the plugin
WebXRFeaturesManager.AddWebXRFeature(WebXRHandTracking.Name, function (xrSessionManager, options) {
    return function () { return new WebXRHandTracking(xrSessionManager, options); };
}, WebXRHandTracking.Version, false);
//# sourceMappingURL=WebXRHandTracking.js.map